# Developing Urbit

1. A Brief Introduction
1.1. Azimuth, the Urbit Address Space
1.2. Accessing Urbit
1.3. Developing on Urbit
2. Nock, A Combinator Language
2.1. Primitive rules and the combinator calculus
2.2. Compound rules
2.3. Kelvin versioning
3. Elements of Hoon (only the 20 necessary runes)
3.1. Reading the Runes
3.2. Irregular Forms
3.3. Hoon as Nock Macro
3.4. Key Data Structures
3.4.1. Cores, Gates, Doors
3.4.2. Molds
3.4.3. Maps, sets, trees
3.5. Generators
3.5.1. Naked
3.5.2. `%say`
3.5.3. `%ask`
3.6. Libraries
3.7. Unit Tests
3.8. Building Code
4. Advanced Hoon (the rest of the non-obscure runes)
4.1. Cores
4.1.1. Metallicity
4.1.2. Common Patterns
4.2. Molds
4.2.1. Polymorphism
4.3. Rune Families
4.4. Marks and Structures
4.5. Helpful Tools (`++cury`, `++cork`, zap runes, etc.)
4.6. Deep Dives
4.6.1. Text Stream Parsing
4.6.2. JSON
4.6.3. Sail/XML
5. The Urbit Kernel
5.1. Arvo
5.1.1. Zuse + Lull
5.4. Ames (Major)
5.5. Behn (Minor)
5.6. Clay (Major)
5.6.1. Ford
5.6.2. Scrying
5.6.3. Marks & conversions
5.7. Dill (Minor)
5.8. Eyre + Iris (Major)
5.10. Jael (Minor)
5.3. Azimuth
5.11. Hoon Parser
6. Userspace
5.9. Gall (Major)
5.9.1. Walkthrough:  Time (Clock)
5.9.2. Walkthrough:  Chat CLI
5.9.3. Walkthrough:  Publish
5.9.4  Walkthrough:  `graph-store`
5.9.5. Walkthrough:  Drum/Helm
5.9.6. Walkthrough:  Bitcoin Interface
5.9.7. Walkthrough:  Bots (Eliza etc.)
7. Supporting Urbit
6.1. Booting and Pills
6.2. `%unix` Events
6.3. Nock Virtual Machines
6.3.1. `++mock`
6.3.2. Interpreters
6.3.2.1. Vere (C)
6.3.2.3. King Haskell (Haskell)
6.3.2.2. Jaque (JVM)
6.4. Jetting
6.4.1. Jet matching, dashboard, etc.
8. Concluding Remarks
A. Comprehensive Table of Hoon Runes
B. Hoon versions
C. Nock versions
D. Hoon Comparison with Other Languages (Lisp, Haskell, OCaml)
E. Zuse/Lull versions
F. Textbook Changelog
