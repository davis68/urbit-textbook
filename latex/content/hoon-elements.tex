\setchapterpreamble[u]{\margintoc}
\chapter{Elements of Hoon}
\labch{hoonelemens}


\section{Reading the Runes}
\labsec{he:reading}

\subsection{Objectives}
\labsec{he:objectives}

The goals of this chapter are for you to be able to:

\begin{enumerate}
  \item  Identify Hoon runes and children in both inline and long-form syntax.
  \item  Trace a short Hoon expression to its final result.
  \item  Execute Hoon code within a running ship.
  \item  Produce output as a side effect using the \sigpam~rune.
\end{enumerate}

\marginnote[2mm]{
Although not a compiled language, the binary-tree structure of Hoon can lead to fairly involved programs which are difficult to type and parse as directly as some other languages afford.  We instead encourage you to use one of three methods to run Hoon programs:

\begin{enumerate}
  \item  The Dojo REPL, which offers some convenient shortcuts to modify the subject for subsequent commands.
  \item  A tight loop of text editor and running fakezod.
  \item  The online interactive sandbox at \url{https://approaching-urbit.com}{\texttt{https://approaching-urbit.com}}
\end{enumerate}
}

For the first several exercises, we will suggest that you utilize one of these methods in particular so that you get a feel for how each works.  After you are more comfortable working with Hoon code on Urbit, we will refrain.


The terminology used is often unfamiliar.  Sometimes this means that you are dealing with a truly new concept (and overloading an older word like "subroutine" or "function" would obfuscate), and sometimes you are dealing with an internal aspect that doesn't really map well to other systems.  The strangeness can be frustrating.  The strangeness can make concepts fresh again.  You'll encounter both as you move ahead.


Each rune accepts at least one child, except for \pzapzap.

\section{Irregular Forms}
\labsec{irregular}

Many runes in common currency are not written in their regular form (tall or wide), but rather using syntactic sugar as irregular.

For instance, \pcenhep~is most frequently written using parentheses \texttt{()} which permits a Lisp-like calling syntax:

\begin{lstlisting}
(add 1 2)
\end{lstlisting}

is equivalent to

\begin{lstlisting}
%-  add  [1 2]
\end{lstlisting}

is also equivalent to

\begin{lstlisting}
%-(add [1 2])
\end{lstlisting}



Hoon parses to an abstract syntax tree (AST), which includes cleaning up all of the sugar syntax and non-primitive runes.  To see the AST of any given Hoon expression, use \pzapcom.

\begin{lstlisting}[style=nonumbers]
> !,(*hoon TODO)
TODO
\end{lstlisting}

\section{Nouns}
\labsec{nouns}

All values in Urbit are nouns, meaning either atoms or cells.  An atom is an unsigned integer.  A cell is a pair of nouns.  Since all values are ultimately integers, we need a way to tell different "kinds" (or applications) of integers apart.  Enter auras.

\subsection{Atoms}
\labsec{atoms}

\marginnote[2mm]{
For what it may be worth, having all integers isn't that different from any other digital machine, built on binary numbers.  These all derive ultimately from \href{https://en.wikipedia.org/wiki/Gödel_numbering}{Gödel numbering} as introduced by Gödel in the proof of his famous incompleteness theorems.  Urbit makes this about as apparent as C does (via \texttt{union}, for instance), but it's first-order accessible via the Dojo REPL.
}
Atoms have auras which are tagged types.  In other words, an aura is a bit of metadata Hoon attaches to a value which tells Urbit how you intend to use a number.  (Of course, ultimately an aura is itself an integer as well!)  The default aura for a value is \patud, unsigned decimal, but of course there are many more.  Aura operations are extremely convenient for converting between representations.  They are also used to enforce type constraints on atoms in expressions and gates.

For instance, to a machine there is no fundamental difference between binary $\ub 1101\,1001$, decimal $217$, and hexadecimal $\ux d9$.  A human coder recognizes them as different encoding schemes and associates tacit information with each:  an assembler instruction, an integer value, a memory address.  Hoon offers two ways of designating values with auras:  either directly by the formatting of the number (such as \texttt{0b1101.1001}) or using the irregular syntax \texttt{`@`}:

\begin{lstlisting}
0b1101.1001
`@ud`0b1101.1001  :: yields 217
`@ux`0b1101.1001  :: yields 0xd9
\end{lstlisting}

\begin{example}
Try the following auras.  See if you can figure out how each one is behaving.

\begin{lstlisting}
`@ud`0x1001.1111
`@ub`0x1001.1111
`@ux`0x1001.1111
`@p`0x1001.1111

`@ud`.1
`@ux`.1
`@ub`.1
`@sb`.1

`@p`0b1111.0000.1111.0000

`@ta`'hello'
`@ud`'hello'
`@ux`'hello'
`@uc`'hello'
`@sb`'hello'
`@rs`'hello'
\end{lstlisting}
\end{example}

\marginnote[2mm]{For a full table of auras, see Appendix~\ref{app:auras}.}
The atom/aura system represents all simple data types in Hoon:  dates, floating-point numbers, text strings, Bitcoin addresses, and so forth.  Each value is represented in least-significant byte (LSB) order; for instance, a text string may be deconstructed as follows:

\begin{tabular}{l}
  \texttt{'Urbit'} \\
  \texttt{0b111.0100.0110.1001.0110.0010.0111.0010.0101.0101} \\
  \texttt{0b111.0100} \texttt{0b110.1001} \texttt{0b110.0010} \\ \texttt{0b111.0010} \texttt{0b101.0101} \\
  $116\;105\;98\;114\;85$ (ASCII characters) \\
  t i b r U
\end{tabular}

Note in the above that leading zeroes are always stripped.  Since each atom is an integer, there is no way to distinguish $0$ from $00$ from $000$ etc.

In this vein, it's worth mentioning that Dojo automatically parses any typed input and disallows invalid representations.  This can lead to confusion until you are accustomed to the type signatures; for instance, try to type \texttt{0b0001} into Dojo.

\paragraph{Operators}.  Hoon has no primitive operators.  Instead, aura-specific functions or \emph{gates} are used to evaluate one or more atoms to produce basic arithmetic results.  Gate names are conventionally prefixed with \texttt{++} which designates them as \emph{arms} of a \emph{core}.  (More on this terminology in Section~\ref{TODO}.)  Some gates operate on any input atom auras, while others enforce strict requirements on the types they will accept.  Gates are commonly invoked using a Lisp-like syntax and a reverse-Polish notation (RPN), with the operator first followed by the first and second (and following) operands.

\begin{tabular}{lll}
  Operation & Function & Example \\ \hline \\
  Addition & \texttt{++add} & \texttt{(add 1 2)} $\rightarrow$ \texttt{3} \\
  Subtraction & \texttt{++sub} & \texttt{(sub 4 3)} $\rightarrow$ \texttt{1} \\
  Multiplication & \texttt{++mul} & \texttt{(mul 5 6)} $\rightarrow$ \texttt{30} \\
  Division & \texttt{++div} & \texttt{(div 8 2)} $\rightarrow$ \texttt{4} \\
  Modulus/Remainder & \texttt{++mod} & \texttt{(mod 12 7)} $\rightarrow$ \texttt{5} \\
\end{tabular}

Following Nock's lead, Hoon uses loobeans ($0$ = $\textrm{true}$) rather than booleans for logical operations.  Loobeans are written \yes~for $\textrm{true}$, $0$, and \no~for $\textrm{false}$, $1$.

\begin{tabular}{lll}
  Operation & Function & Example \\ \hline \\
  Greater than, $>$ & \texttt{++gth} & \texttt{(gth 5 6)} $\rightarrow$ \no \\
  Greater than or equal to, $\geq$ & \texttt{++gte} & \texttt{(gte 5 6)} $\rightarrow$ \no \\
  Less than, $<$ & \texttt{++lth} & \texttt{(lth 5 6)} $\rightarrow$ \yes \\
  Less than or equal to, $\leq$ & \texttt{++lte} & \texttt{(lte 5 6)} $\rightarrow$ \yes \\
  Equals, $=$ & \texttt{=} & \texttt{=(5 5)} $\rightarrow$ \yes \\
  Logical \texttt{AND}, $\land$ & \texttt{\&} & \texttt{\&(\%.y \%.n)} $\rightarrow$ \no \\
  Logical \texttt{OR}, $\lor$ & \texttt{|} & \texttt{|(\%.y \%.n)} $\rightarrow$ \yes \\
  Logical \texttt{NOT}, $\neg$ & \texttt{!} & \texttt{!\%.y} $\rightarrow$ \no \\
\end{tabular}

Since all operations are explicitly invoked Lisp-style within nested parentheses, there is no need for explicit operator precedence rules.

$$
(a < b) \land ((b \geq c) \lor d)
$$

\begin{lstlisting}
\&((lth a b) (|((gte b c) d)))
\end{lstlisting}

The Hoon standard library, largely in \zuse, further defines bitwise operations, arithmetic for both integers and floating-point values (half-width, single-precision, double-precision, and quadruple-precision), string operations, and more.  These are introduced incidentally as necessary and listed in more detail in Appendix~\ref{stdlib}.

\subsection{Cells}
\labsec{cells}

Just as all structures in Nock are binary trees, so too with Hoon.  This can occasionally lead to some awkward addressing when composing tetchy library code segments that need to interface with many different kinds of gates, but by and large is an extremely helpful discipline of thought.


binary tree format
flattened representation/convention

\marginnote[2mm]{Binary trees are explained in more detail in Section~\ref{nock0}.}

Hoon values are addressed as elements in a binary tree.


Finally, the most general mold is \texttt{*} which simply matches any noun—and thus anything in Hoon at all.

\section{Hoon as Nock Macro}
\labsec{macro}

The point of employing Hoon is, of course, that Hoon compiles to Nock.  Rather than even say \emph{compile}, however, we should really just say Hoon is a \emph{macro} of Nock.  Each Hoon rune, data structure, and effect corresponds to a well-defined Nock primitive form.  We may say that Hoon is to Nock as C is to assembler, except that the Hoon-to-Nock transformation is completely specified and portable.  Hoon is ultimately defined in terms of Nock; many Hoon runes are defined in terms of other more fundamental Hoon runes, but all runes parse unambiguously to Nock expressions.


Hoon expands on Nock primarily through the introduction of metadata


Each Hoon rune has an unambiguous mapping to a Nock representation.  Furthermore, each rune has a well-defined binary tree structure and produces a similarly well-structured abstract syntax tree (AST).  As we systematically introduce runes, we will expand on what this means in each case:  for now, let's examine two runes without regard for their role.

\begin{enumerate}
  \item  \pbartis~produces a \emph{gate} or function.  Every gate has the same shape, which means certain assumptions about data access and availability can be made.

    \begin{lstlisting}
::  XOR two binary atoms
|=  [a=@ub b=@ub]
`@ub`(mix a b)
    \end{lstlisting}

    maps to the Nock code

    \begin{lstlisting}
[8 [1 0 0] [1 8 [9 1.494 0 4.095] 9 2 10 [6 [0 28] 0 29] 0 2] 0 1]
    \end{lstlisting}

    This Nock code is fully annotated in Example~\ref{ex:nock:xor}.

  \item  TODO
\end{enumerate}


We call Hoon's data type specifications \emph{molds}.  Molds are more general than atoms and cells, but these form particular cases.  Hoon uses molds as a way of matching Nock tree structures (including Hoon metadata tags such as auras).



\marginnote[2mm]{
Be careful to not confuse \irrtis, which evaluates to \dottis, with the various \wut~runes like \wuttis.
}

\section{Key Data Structures}
\labsec{keydata}

\subsection{Lists}
\labsec{lists}

\subsection{Text}
\labsec{text}

\marginnote[2mm]{Both cords and tapes are casually referred to as strings.}

Hoon recognizes two basic text types:  the \emph{cord} or \patt~and the \emph{tape}.  Cords are single atoms containing the text as UTF-8 bytes interpreted as a single stacked number.  Tapes are lists of individual one-element cords.

\marginnote[2mm]{Lists are null-terminated, and thus so are tapes.}

Cords are useful as a compact primary storage and data transfer format, but frequently parsing and processing involves converting the text into tape format.  There are more utilities for handling tapes, as they are already broken up in a legible manner.

\begin{lstlisting}
++  trip
  |=  a=@  ^-  tape
  ?:  =(0 (met 3 a))  ~
  [^-(@ta (end 3 1 a)) $(a (rsh 3 1 a))]
\end{lstlisting}


For instance, \texttt{trip} converts a cord to a tape; \texttt{crip} does the opposite.

%\marginnote[2mm]{
%\begin{lstlisting}
%++  trip
%  |=  a/@  ^-  tape
%  ?:  =(0 (met 3 a))  ~
%  [^-(@ta (end 3 1 a)) $(a (rsh 3 1 a))]
%\end{lstlisting}
%\texttt{++met}, \texttt{++end}, and \texttt{++rsh} are bitwise manipulation gates.
%}

\marginnote[2mm]{
%\begin{lstlisting}
\texttt{++  crip  |=(a=tape `@t`(rap 3 a))}
%\end{lstlisting}

\texttt{++rap} assembles the list interpreted as cords with block size of $2^3$ (in this case).
}


All text in Urbit is UTF-8 (\emph{a fortiori} ASCII).  The \patc~UTF-32 aura is only used by \dill and Hood (the Dojo terminal agent).


\subsection{Cores, Gates, Doors}
\labsec{doors}

> anyway you can explicitly set the sample in an iron core
but you can't use it with +roll
New messages below
11:54 (~master-morzod)
\gold~is the default, read/write everything; \iron~is for functions (write to the sample with a contravariant nest check), \lead~is "hide the whole payload", \zinc~completes the matrix
but has probably never been used
\iron~lets you refer to a typed gate (without wetness), without depending on all the details of the subject it was defined against
\lead~lets you export a library interface but hide the implementation details

\subsection{Molds}
\labsec{molds}

\subsection{Maps, Sets, Tree}
\labsec{macro}

\section{Generators}
\labsec{he:generators}

Generators are standalone Hoon expressions that evaluate and may produce side effects, as appropriate.  They are closely analogous to simple scripts in languages such as Bash or Python.  By using generators, one is able to develop more involved Hoon code and run it repeatedly without awkwardness.

\marginnote[2mm]{You may also see commands beginning with \texttt{|}; these are TODO commands instead.}

To run a generator on a ship, prefix its name with \texttt{+}.  Arguments may be required or optional.

\begin{lstlisting}[style=nonumbers]
+moon TODO
\end{lstlisting}

\subsection{Running Developer Code on an Urbit Ship}
\labsec{he:running}

Since the Urbit file system, called \clay, is independent of the Unix file system on which it is hosted, you must commit your Unix-side code into your pier.

If we \texttt{cd} into the ship's pier in Unix and \texttt{ls} the directory contents, by default we see nothing.  With \texttt{ls -l}, a \texttt{.urb/} directory containing the ship's configuration and contents in obfuscated format becomes visible.  This directory is not interpretable by us now, so we leave it until a later discussion of the Urbit binary.  To move files into \clay, we must synchronize Urbit and Unix together.  We initiate this inside of the running ship; run the Urbit system command:

\begin{lstlisting}[style=nonumbers]
|mount %
\end{lstlisting}

where \texttt{\%} represents the current (home) path in \clay.  Unix-side, run \texttt{ls} again and a \texttt{home/} directory appears with a number of children:  \texttt{app/}, \texttt{gen/}, \texttt{lib/}, \texttt{mar/}, and so forth.  This is the internal esoteric structure of \clay~made manifest to Unix.

\marginnote[2mm]{\clay~implements several \emph{desks}, which are like branches in version control systems; the most important of these are \chome~and \ckids.}
Generally speaking, we compose \emph{generators}, which are short Hoon scripts.  These are created in or copied into the \texttt{home/mar/} directory, and then must be synchronized with Urbit's \clay.  Commit the change:

\begin{lstlisting}[style=nonumbers]
|commit %home
\end{lstlisting}

and the generator is now available within \clay.

\subsection{Naked Generators}
\labsec{he:naked}

As we start to compose generators,

A naked generator is so called because it contains no metadata for the Arvo interpreter.

\subsection{\say~generators}
\labsec{he:say}

\subsection{\ask~generators}
\labsec{he:ask}

\section{Libraries}
\labsec{libraries}

\section{Unit Tests}
\labsec{unittests}

\section{Building Code}
\labsec{building}

\section{Exercises}

The vertical direction presents a six-step process that prompts students to
read the problem statement, figure out the data that is needed to represent the information of interest, and illustrate their insight with concrete examples;

articulate a purpose statement that concisely describes what the function or program is supposed to compute, including a signature;

work through functional examples, that is, explain what the function or program is supposed to produce when given certain inputs, based on steps 1 and 2;

create an outline of the program, based on steps 1 and 2;

fill in the outline from step 4, using steps 2 and 3; and

turn the examples from step 2 into a test suite for the program from step 5.
