\setchapterpreamble[u]{\margintoc}
\chapter{The Kernel}
\labch{kernel}


\section{Arvo}
\labsec{arvo}

Arvo is essentially an event handler which can coordinate and dispatch messages between vanes as well as emit \unix~events to the underlying (presumed Unix-compatible) host OS.  Arvo does not carry out several tasks specific to the machine hardware, such as memory allocation, system thread management, and hardware- or firmware-level operations.  These are left to the king and serf, or the daemon processes which together run Arvo.  Collectively, the system-level instrumentation of Arvo is described in Chapter~\ref{support}.

\subsection[\zuse~\&~\lull]{\zuse~and \lull}
\labsec{zuse}

\zuse~and \lull~define common structures and library functions for Arvo.

subject wrapped

\section[\ames]{\ames, A Network}
\labsec{ames}

In a sense, \ames~is the operative definition of an urbit on the network.  That is, from outside of one's own urbit, the only specification that must be hewed to is that \ames~behaves a certain way in response to events.

\ames~implements a system expecting—and delivering—guaranteed one-time delivery.  This derives from an observation by \citeauthor{Yarvin2016}~in the Whitepaper:  "bus v. commands whatever"

UDP packet structure

network events
acks \& nacks


\section[\behn]{\behn, A Timer}
\labsec{behn}

\behn~is a simple vane that promises to emit events after—but never before—their timestamp.  This guarantee

As the shortest vane, we commend \behn~to the student as an excellent subject for a first dive into the structure of a vane.

\behn~maintains an event handler and a state.

Any task may have one of the following states:

\begin{lstlisting}
%born  born:event-core
%rest  (rest:event-core date=p.task)
%drip  (drip:event-core move=p.task)
%huck  (huck:event-core syn.task)
%trim  trim:event-core
%vega  vega:event-core
%wait  (wait:event-core date=p.task)
%wake  (wake:event-core error=~)
\end{lstlisting}


\section[\clay]{\clay, A File System}
\labsec{clay}

\subsection[\ford]{\ford, A Build System}
\labsec{ford}

\subsection{Scrying}
\labsec{scry}

\subsection[Marks]{Marks and conversions}
\labsec{marks2}

\section[\dill]{\dill, A Terminal driver}
\labsec{dill}

\section[\eyre~\&~\iris]{\eyre~and \iris, Server and Client Vanes}
\labsec{eyre}

\section[\jael]{\jael, Secretkeeper}
\labsec{jael}

\marginnote[2mm]{
\jael is named after Jael, the wife of Heber, who kept mum and slew fleeing enemy general Sisera in Judges 4.
}

\jael~weighs in as one of the shorter vanes

As of Arvo XXX K, the

\begin{lstlisting}

\end{lstlisting}

\section[Azimuth]{Azimuth, Address Space Management}
\labsec{azimuth2}

Urbit HD wallet


\paragraph{Comet keys}.  Comets do not have an associated Urbit HD wallet, and their keys work slightly differently.

> yeah thats how comet mining works. so you'd just put the private key you generated for a comet on the card, and this would be the ames DH exchange private key. i suppose you could still obfuscate it with a master ticket @q, by just picking a 128 bit hash, but it would be used differently than a normal azimuth master key, which is a @q used to derive a bunch of ethereum wallets private keys (and ultimately the initial network key, but that isnt required).
9:15
>and yeah whether a key works at the time it is mined is dependent on whether the routing node automatically assigned to the comet public key is currently working
>~lagrev-nocfep: the comets name is its public key


\section[Hoon Parser]{The Hoon Parser}
\labsec{hoonparse}
